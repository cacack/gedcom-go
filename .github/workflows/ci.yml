name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    name: Test
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        go: ['1.21', '1.22', '1.23', '1.24', '1.25']

    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: ${{ matrix.go }}
        cache: true

    - name: Verify dependencies
      run: go mod verify

    - name: Run tests
      run: go test -v -race -coverprofile=coverage.out -covermode=atomic ./charset ./decoder ./encoder ./gedcom ./parser ./validator ./version
      shell: bash

    - name: Upload coverage to Codecov
      if: matrix.os == 'ubuntu-latest' && matrix.go == '1.25'
      uses: codecov/codecov-action@v5
      with:
        file: ./coverage.out
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false

  coverage:
    name: Coverage Check
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: '1.25'
        cache: true

    - name: Generate coverage
      run: go test -coverprofile=coverage.out -covermode=atomic ./charset ./decoder ./encoder ./gedcom ./parser ./validator ./version

    - name: Check coverage thresholds
      uses: vladopajic/go-test-coverage@v2
      with:
        profile: coverage.out
        local-prefix: github.com/cacack/gedcom-go
        threshold-file: 0
        threshold-package: 85
        threshold-total: 85

    - name: Per-package coverage report
      run: |
        echo "## Per-Package Coverage Report"
        echo ""
        echo "| Package | Coverage | Status |"
        echo "|---------|----------|--------|"
        for pkg in charset decoder encoder gedcom parser validator version; do
          COV=$(go tool cover -func=coverage.out | grep "github.com/cacack/gedcom-go/$pkg" | tail -1 | awk '{print $3}')
          PCT=$(echo "$COV" | sed 's/%//')
          if (( $(echo "$PCT >= 85.0" | bc -l) )); then
            echo "| $pkg | $COV | ✅ |"
          else
            echo "| $pkg | $COV | ❌ |"
          fi
        done
        echo ""
        TOTAL=$(go tool cover -func=coverage.out | tail -1 | awk '{print $3}')
        echo "**Total: $TOTAL**"

  lint:
    name: Lint
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: '1.25'

    - name: Run golangci-lint
      uses: golangci/golangci-lint-action@v9
      with:
        version: v2.7.2

  format:
    name: Format Check
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: '1.25'

    - name: Check formatting
      run: |
        if [ -n "$(gofmt -l .)" ]; then
          echo "Go files must be formatted with gofmt. Please run:"
          echo "  gofmt -w ."
          gofmt -l .
          exit 1
        fi

    - name: Run go vet
      run: go vet ./...

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: '1.25'

    - name: Verify dependencies
      run: go mod verify

    - name: Run govulncheck
      run: |
        go install golang.org/x/vuln/cmd/govulncheck@latest
        govulncheck ./...

    - name: Run gosec
      run: |
        go install github.com/securego/gosec/v2/cmd/gosec@latest
        gosec -fmt sarif -out gosec-results.sarif ./...

    - name: Upload gosec results to GitHub Security
      uses: github/codeql-action/upload-sarif@v4
      if: success() || failure()
      with:
        sarif_file: gosec-results.sarif

  build-examples:
    name: Build Examples
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: '1.25'

    - name: Build parse example
      run: go build -o /tmp/example-parse ./examples/parse

    - name: Build encode example
      run: go build -o /tmp/example-encode ./examples/encode

    - name: Build query example
      run: go build -o /tmp/example-query ./examples/query

    - name: Build validate example
      run: go build -o /tmp/example-validate ./examples/validate

    - name: Run parse example
      run: |
        if [ -f testdata/gedcom-5.5/minimal.ged ]; then
          /tmp/example-parse testdata/gedcom-5.5/minimal.ged
        fi

  pr-title:
    name: PR Title Check
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Check PR title is not conventional commit format
        run: |
          TITLE="${{ github.event.pull_request.title }}"

          # Exempt release-please PRs (they use chore(main): release X.Y.Z)
          if echo "$TITLE" | grep -qE "^chore\(main\): release [0-9]"; then
            echo "✅ Release-please PR exempt from title check"
            exit 0
          fi

          PATTERN="^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?!?:"
          if echo "$TITLE" | grep -qE "$PATTERN"; then
            echo "::error::PR title should NOT use conventional commit format."
            echo "Use descriptive titles (e.g., 'Add date parsing') not 'feat(date): ...'"
            echo "Conventional commits are for commit messages only."
            exit 1
          fi
          echo "✅ PR title valid: $TITLE"

  # Gate job for branch protection - only require this one check
  ci-success:
    name: CI Success
    runs-on: ubuntu-latest
    needs: [test, coverage, lint, format, security, build-examples, pr-title]
    if: always()
    steps:
      - name: Check all jobs passed
        run: |
          # pr-title is skipped on push events, which is expected
          if [[ "${{ contains(needs.*.result, 'failure') }}" == "true" ]]; then
            echo "❌ Some jobs failed"
            exit 1
          fi
          if [[ "${{ contains(needs.*.result, 'cancelled') }}" == "true" ]]; then
            echo "❌ Some jobs were cancelled"
            exit 1
          fi
          echo "✅ All CI jobs passed"
