name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Restrict default GITHUB_TOKEN permissions (principle of least privilege)
permissions:
  contents: read

# Prevent resource abuse from multiple concurrent runs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  test:
    name: Test
    runs-on: ${{ matrix.os }}
    timeout-minutes: 15
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        go: ['1.24', '1.25']

    steps:
    - name: Harden Runner
      if: matrix.os == 'ubuntu-latest'
      uses: step-security/harden-runner@5ef0c079ce82195b2a36a210272d6b661572d83e # v2.14.2
      with:
        egress-policy: audit

    - name: Checkout code
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

    - name: Set up Go
      uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6
      with:
        go-version: ${{ matrix.go }}
        cache: true

    - name: Verify dependencies
      run: go mod verify

    - name: Run tests
      run: go test -v -race -coverprofile=coverage.out -covermode=atomic ./charset ./decoder ./encoder ./gedcom ./parser ./validator ./version
      shell: bash

    - name: Upload coverage to Codecov
      if: matrix.os == 'ubuntu-latest' && matrix.go == '1.25'
      uses: codecov/codecov-action@671740ac38dd9b0130fbe1cec585b89eea48d3de # v5
      with:
        token: ${{ secrets.CODECOV_TOKEN }}
        files: ./coverage.out
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false

  coverage:
    name: Coverage Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
    - name: Checkout code
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

    - name: Set up Go
      uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6
      with:
        go-version: '1.25'
        cache: true

    - name: Generate coverage
      run: go test -coverprofile=coverage.out -covermode=atomic ./charset ./decoder ./encoder ./gedcom ./parser ./validator ./version

    - name: Check coverage thresholds
      uses: vladopajic/go-test-coverage@679e6807f68f2440a4c43d386442a1d0041838a9 # v2
      with:
        profile: coverage.out
        local-prefix: github.com/cacack/gedcom-go
        threshold-file: 0
        threshold-package: 85
        threshold-total: 85

    - name: Per-package coverage report
      run: |
        echo "## Per-Package Coverage Report"
        echo ""
        echo "| Package | Coverage | Status |"
        echo "|---------|----------|--------|"
        for pkg in charset decoder encoder gedcom parser validator version; do
          COV=$(go tool cover -func=coverage.out | grep "github.com/cacack/gedcom-go/$pkg" | tail -1 | awk '{print $3}')
          PCT=$(echo "$COV" | sed 's/%//')
          if (( $(echo "$PCT >= 85.0" | bc -l) )); then
            echo "| $pkg | $COV | ✅ |"
          else
            echo "| $pkg | $COV | ❌ |"
          fi
        done
        echo ""
        TOTAL=$(go tool cover -func=coverage.out | tail -1 | awk '{print $3}')
        echo "**Total: $TOTAL**"

  lint:
    name: Lint
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
    - name: Checkout code
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

    - name: Set up Go
      uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6
      with:
        go-version: '1.25'

    - name: Run golangci-lint
      uses: golangci/golangci-lint-action@1e7e51e771db61008b38414a730f564565cf7c20 # v9
      with:
        version: v2.7.2

  format:
    name: Format Check
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
    - name: Checkout code
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

    - name: Set up Go
      uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6
      with:
        go-version: '1.25'

    - name: Check formatting
      run: |
        if [ -n "$(gofmt -l .)" ]; then
          echo "Go files must be formatted with gofmt. Please run:"
          echo "  gofmt -w ."
          gofmt -l .
          exit 1
        fi

    - name: Run go vet
      run: go vet ./...

  # Dependency review - blocks PRs introducing vulnerable dependencies
  dependency-review:
    name: Dependency Review
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event_name == 'pull_request'
    steps:
    - name: Checkout code
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

    - name: Dependency Review
      uses: actions/dependency-review-action@3c4e3dcb1aa7874d2c16be7d79418e9b7efd6261 # v4
      with:
        fail-on-severity: high
        allow-licenses: MIT, Apache-2.0, BSD-2-Clause, BSD-3-Clause, ISC, MPL-2.0, 0BSD, CC0-1.0, Unlicense
        # golang.org/x/text has BSD-3-Clause + Google patent grant, allow explicitly
        allow-dependencies-licenses: pkg:golang/golang.org/x/text

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      security-events: write
    steps:
    - name: Harden Runner
      uses: step-security/harden-runner@5ef0c079ce82195b2a36a210272d6b661572d83e # v2.14.2
      with:
        egress-policy: audit

    - name: Checkout code
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
      with:
        fetch-depth: 0  # Full history for gitleaks

    - name: Set up Go
      uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6
      with:
        go-version: '1.25'

    - name: Verify dependencies
      run: go mod verify

    - name: Run govulncheck
      run: |
        go install golang.org/x/vuln/cmd/govulncheck@latest
        govulncheck -format sarif ./... > govulncheck-results.sarif || true
        govulncheck ./...

    - name: Upload govulncheck results to GitHub Security
      uses: github/codeql-action/upload-sarif@6bc82e05fd0ea64601dd4b465378bbcf57de0314 # v4
      if: success() || failure()
      with:
        sarif_file: govulncheck-results.sarif
        category: govulncheck

    - name: Run gosec
      run: |
        go install github.com/securego/gosec/v2/cmd/gosec@424fc4cd9c82ea0fd6bee9cd49c2db2c3cc0c93f # v2.22.11
        gosec -fmt sarif -out gosec-results.sarif ./...

    - name: Upload gosec results to GitHub Security
      uses: github/codeql-action/upload-sarif@6bc82e05fd0ea64601dd4b465378bbcf57de0314 # v4
      if: success() || failure()
      with:
        sarif_file: gosec-results.sarif
        category: gosec

    # Secret detection
    - name: Detect secrets (gitleaks)
      uses: gitleaks/gitleaks-action@ff98106e4c7b2bc287b24eaf42907196329070c7 # v2
      continue-on-error: true  # Don't block other scans
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    # Trivy: Filesystem vulnerability and misconfiguration scanning
    - name: Trivy filesystem scan
      uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8 # 0.33.1
      continue-on-error: true  # Produce SARIF even on findings
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
        severity: 'CRITICAL,HIGH,MEDIUM'

    - name: Upload Trivy results to GitHub Security
      uses: github/codeql-action/upload-sarif@6bc82e05fd0ea64601dd4b465378bbcf57de0314 # v4
      if: success() || failure()
      with:
        sarif_file: trivy-results.sarif
        category: trivy

    # Semgrep: Rule-based static analysis
    - name: Semgrep scan
      continue-on-error: true  # Produce SARIF even on findings
      run: |
        docker run --rm -v "${PWD}:/src" \
          returntocorp/semgrep semgrep \
          --config p/security-audit \
          --config p/secrets \
          --config p/golang \
          --sarif --output /src/semgrep.sarif \
          /src

    - name: Upload Semgrep results to GitHub Security
      uses: github/codeql-action/upload-sarif@6bc82e05fd0ea64601dd4b465378bbcf57de0314 # v4
      if: success() || failure()
      with:
        sarif_file: semgrep.sarif
        category: semgrep

  build-examples:
    name: Build Examples
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
    - name: Harden Runner
      uses: step-security/harden-runner@5ef0c079ce82195b2a36a210272d6b661572d83e # v2.14.2
      with:
        egress-policy: audit

    - name: Checkout code
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6

    - name: Set up Go
      uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6
      with:
        go-version: '1.25'

    - name: Build parse example
      run: go build -o /tmp/example-parse ./examples/parse

    - name: Build encode example
      run: go build -o /tmp/example-encode ./examples/encode

    - name: Build query example
      run: go build -o /tmp/example-query ./examples/query

    - name: Build validate example
      run: go build -o /tmp/example-validate ./examples/validate

    - name: Run parse example
      run: |
        if [ -f testdata/gedcom-5.5/minimal.ged ]; then
          /tmp/example-parse testdata/gedcom-5.5/minimal.ged
        fi

  api-compatibility:
    name: API Compatibility Check
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
        with:
          fetch-depth: 0  # Full history for tags and commits

      - name: Set up Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6
        with:
          go-version: '1.25'

      - name: Install apidiff
        run: go install golang.org/x/exp/cmd/apidiff@latest

      - name: Check API compatibility
        run: |
          # Get latest release tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -z "$LATEST_TAG" ]; then
            echo "✅ No release tags found, skipping API compatibility check"
            exit 0
          fi

          echo "Comparing API against $LATEST_TAG"

          # Clone old version to temp directory (worktrees have issues with apidiff)
          OLD_DIR=$(mktemp -d)
          git clone --depth 1 --branch "$LATEST_TAG" "https://github.com/${{ github.repository }}.git" "$OLD_DIR" --quiet
          trap "rm -rf '$OLD_DIR'" EXIT

          # Export old API to file, then compare against current
          # This is more reliable than comparing directories directly
          API_FILE=$(mktemp)
          (cd "$OLD_DIR" && go mod download && apidiff -m -w "$API_FILE" .)
          go mod download

          # Run apidiff comparing exported API against current
          # Use set +e to prevent immediate exit on non-zero return
          set +e
          APIDIFF_OUT=$(apidiff -m "$API_FILE" . 2>&1)
          APIDIFF_STATUS=$?
          set -e

          # Fail if apidiff itself errored (not just found incompatibilities)
          if [ $APIDIFF_STATUS -ne 0 ] && ! echo "$APIDIFF_OUT" | grep -q "Incompatible changes:"; then
            echo "::error::apidiff failed to run:"
            echo "$APIDIFF_OUT"
            exit 1
          fi

          # Check for incompatible (breaking) changes
          if echo "$APIDIFF_OUT" | grep -q "Incompatible changes:"; then
            echo "⚠️  Breaking API changes detected:"
            echo "$APIDIFF_OUT"
            echo ""

            # Check if commits declare breaking change via conventional commits
            # Look for: feat!:, fix!:, refactor!:, or BREAKING CHANGE: in commit body
            # Check both branch-specific commits AND commits on main since the last release,
            # since a breaking change may already be merged to main but not yet released.
            COMMITS=$(git log --format="%s%n%b" "$LATEST_TAG..HEAD")

            if echo "$COMMITS" | grep -qE '^(feat|fix|refactor|perf|docs|style|test|build|ci|chore)!:|BREAKING CHANGE:'; then
              echo "✅ Breaking change properly declared in commit message"
              echo "   Release-please will bump major version"
              exit 0
            else
              echo ""
              echo "::error::Breaking API changes detected but not declared in commits!"
              echo ""
              echo "To fix, use one of these conventional commit formats:"
              echo "  feat!: description of breaking change"
              echo "  fix!: description of breaking change"
              echo "  feat: description"
              echo ""
              echo "  BREAKING CHANGE: explanation of what breaks"
              echo ""
              echo "This ensures release-please creates a major version bump."
              exit 1
            fi
          else
            echo "✅ No breaking API changes detected"
            if [ -n "$APIDIFF_OUT" ]; then
              echo ""
              echo "Compatible changes:"
              echo "$APIDIFF_OUT"
            fi
          fi

  pr-title:
    name: PR Title Check
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event_name == 'pull_request'
    steps:
      - name: Check PR title is not conventional commit format
        run: |
          TITLE="${{ github.event.pull_request.title }}"

          # Exempt release-please PRs (they use chore(main): release X.Y.Z)
          if echo "$TITLE" | grep -qE "^chore\(main\): release [0-9]"; then
            echo "✅ Release-please PR exempt from title check"
            exit 0
          fi

          # Exempt Dependabot PRs (they use conventional commit format by default)
          if [[ "${{ github.event.pull_request.user.login }}" == "dependabot[bot]" ]]; then
            echo "✅ Dependabot PR exempt from title check"
            exit 0
          fi

          PATTERN="^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?!?:"
          if echo "$TITLE" | grep -qE "$PATTERN"; then
            echo "::error::PR title should NOT use conventional commit format."
            echo "Use descriptive titles (e.g., 'Add date parsing') not 'feat(date): ...'"
            echo "Conventional commits are for commit messages only."
            exit 1
          fi
          echo "✅ PR title valid: $TITLE"

  commit-type:
    name: Commit Type Check
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
        with:
          fetch-depth: 0

      - name: Check feat/fix commits touch library code
        run: |
          # Library packages that constitute the public module
          LIB_PATTERN='^(charset|converter|decoder|encoder|gedcom|parser|validator|version)/'

          FAILED=0
          for SHA in $(git log --format="%H" origin/main..HEAD); do
            SUBJECT=$(git log -1 --format="%s" "$SHA")

            # Only check feat: and fix: commits (including scoped variants)
            if ! echo "$SUBJECT" | grep -qE '^(feat|fix)(\(.+\))?!?:'; then
              continue
            fi

            # Check if at least one changed file is in a library package
            FILES=$(git diff-tree --no-commit-id --name-only -r "$SHA")
            if ! echo "$FILES" | grep -qE "$LIB_PATTERN"; then
              echo "::error::Commit '$SUBJECT' uses feat/fix type but touches no library code."
              echo "  feat/fix are reserved for library changes (what users consume)."
              echo "  Use ci, build, docs, refactor, etc. for non-library changes."
              echo "  Files changed:"
              echo "$FILES" | sed 's/^/    /'
              echo ""
              FAILED=1
            fi
          done

          if [ "$FAILED" -eq 1 ]; then
            exit 1
          fi
          echo "✅ All feat/fix commits touch library code"

  # Gate job for branch protection - only require this one check
  ci-success:
    name: CI Success
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [test, coverage, lint, format, dependency-review, security, build-examples, api-compatibility, pr-title, commit-type]
    if: always()
    steps:
      - name: Check all jobs passed
        run: |
          # pr-title is skipped on push events, which is expected
          if [[ "${{ contains(needs.*.result, 'failure') }}" == "true" ]]; then
            echo "❌ Some jobs failed"
            exit 1
          fi
          if [[ "${{ contains(needs.*.result, 'cancelled') }}" == "true" ]]; then
            echo "❌ Some jobs were cancelled"
            exit 1
          fi
          echo "✅ All CI jobs passed"
